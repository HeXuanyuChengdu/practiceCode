15.
    输出为:"i=1.2"
16.
    i=4 ,j=6,k=6
    分析： i*=i++;
        首先等效为i=i*i++;
        按照运算符优先级，会首先取i++的值，但是后缀自增的特性，会在计算完成后才自增，所以(i++)=2
        之后，计算(i*(i++)) = 4
        计算完成后，进行i自增运算 ， i 增加为3
        最后，进行赋值运算，把(i*i++)的赋值给了i，覆盖掉了3，变为了4
        余下两个表达式的执行顺序类似的
17.
    无法得到运行结果，编译器会报错
    因为赋值表达式 a = b 本身有一个值，这个值为1
    因此语句等效为if(1)....
    但是Java中不允许boolean与int进行类型转换，因此程序无法通过编译，编译器会报错 不兼容的类型
18.
    输出结果为 1和3
    8>>>3  1000>>>3  -> 0001
    运算顺序：先移位运算再位运算
    等效为 0001 | 0010 -> 0011=3
19.
    最有效的计算方法是 2<<3
    位移计算理论上来说是直接对二进制位数操作，通常只需要1个CPU指令周期；
    而一般的乘法运算2*8需要调用乘法指令，可能会涉及更多的计算周期
    但经过现代编译器优化以后，两种方式的实际差距可能并不是很明显



